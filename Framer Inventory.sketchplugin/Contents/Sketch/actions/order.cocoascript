
var userSelection = nil
var selectionMap = [,]
var artboardsMapsArray = []

var typeWarning = ""

function OrderInventory () {}

OrderInventory.initSelection = function(selection) {
	userSelection = selection
	selectionMap = [,]
	artboardsMapsArray = []
	OrderInventory.composeSelectionMap()
}

OrderInventory.mapSize = function(map) {
	return Object.keys(map).length
}

OrderInventory.presentOrder = function(array) {
	if (array == nil) { return }
	for (var i = 0; i < array.count(); i++) { log(i + ": " + [[array objectAtIndex:i] name]) } log("")
}

OrderInventory.getWarnings = function() {
	return typeWarning
}

OrderInventory.composeSelectionMap = function() {
	for (var i = 0; i < userSelection.count(); i++) {
		var layer = [userSelection objectAtIndex:i]
		var type = [layer className]
		var layerName = [layer name]
		
		if (selectionMap[layerName] == nil) { 
			if (layerName != nil && type != nil) { selectionMap[layerName] = type }
			else { if(showLog) { log("ERROR: Nil key or value for " + layer) } }
		}
		else {
			var currentvalue = selectionMap[layerName]
			if (![currentvalue isEqualToString:type]) {
				typeWarning = layerName
				if (showLog) { log("WARNING: Several types of " + layerName) }
			}
		}
	}
}

OrderInventory.removeDuplicatedLayers = function(array) {
	var cleanedLayers = NSArray.new()
	if (array == nil) { return cleanedLayers }
	
	for (var i = 0; i < array.count(); i++) {
		var currentLayer = [array objectAtIndex: i]
		var isExist = false

		for (var c = 0; c < cleanedLayers.count(); c++) {
			var currentCleaned = [cleanedLayers objectAtIndex: c]

			if ([[currentLayer name] isEqualToString:[currentCleaned name]]) {
				isExist = true
				break
			}
		}

		if (!isExist) {
			cleanedLayers = FramerInventory.addItemToArray(currentLayer, cleanedLayers)
		}
	}
	
	return cleanedLayers
}







OrderInventory.returnLayers = function(layer) {
	return layer.layers().array()
}

OrderInventory.isContainer = function(layer) {
	if (layer == nil) { return false }
	var type = [layer className]
	
	if (TypeInventory.isLayerGroup(type) || TypeInventory.isArtboardType(type)) { return true }
	return false
}

OrderInventory.isFound = function(layer) {
	if (layer == nil || [layer className] == nil || [layer name] == nil) { return false }
	var type = [layer className]
	var layerName = [layer name]
	
	if ([type isEqualToString:selectionMap[layerName]]) { return true }
	return false
}

OrderInventory.returnScope = function(layer) {
	if (layer == nil) { return nil }

	if (OrderInventory.isFound(layer)) { 
		var localOrder = NSArray.new()
		return FramerInventory.addItemToArray(layer, localOrder)
	}
	else {
		if (OrderInventory.isContainer(layer)) {
			var layers = OrderInventory.returnLayers(layer)
			var localOrder = NSArray.new()

			for (var i = 0; i < layers.count(); i++) {
				var currentChild = [layers objectAtIndex:i]
				var localScope = OrderInventory.returnScope(currentChild)
				
				if (localScope != nil && localScope.count() > 0) {
					localOrder = FramerInventory.addArrayToArray(localScope, localOrder)
				}
				
			}

			if (localOrder == nil || localOrder.count() == 0) { return nil }
			return localOrder
		}
		else { return nil }
	}
}

OrderInventory.returnArtboardOrder = function(artboard) {
	if (artboard == nil || !TypeInventory.isArtboardType([artboard className])) { return nil }

	var artboardScope = OrderInventory.returnScope(artboard)
	return OrderInventory.removeDuplicatedLayers(artboardScope)
}






OrderInventory.returnMapFromArray = function(array) {
	var map = [,]
	if (array == nil) { return map }
	
	for (var i = 0; i < array.count(); i++) {
		var layerName = [[array objectAtIndex:i] name]
		if (layerName != nil) {
			map[layerName] = i
		}
	}
	return map
}

OrderInventory.returnUnorderedLayers = function() {
	var artboards = FramerInventory.getCurrentPage().artboards()
	var globalOrder = NSArray.new()
	
	for (var i = 0; i < artboards.count(); i++) {
		var artboard = [artboards objectAtIndex:i]

		var localOrder = OrderInventory.returnArtboardOrder(artboard)
		var localMap = OrderInventory.returnMapFromArray(localOrder)

		artboardsMapsArray.push(localMap)

		globalOrder = FramerInventory.addArrayToArray(localOrder, globalOrder)
	}
	
	return OrderInventory.removeDuplicatedLayers(globalOrder)
}

OrderInventory.currentPosition = function(a, b) {
	if (a == nil || b == nil) { return 0 }
	else if (a < b) { return -1 }
	else if (a > b) { return 1 }
	
	return 0
}

OrderInventory.analyseAveragePosition = function(baseLayer, currentLayer) {
	var localScore = 0
	
	for (var i = 0; i < artboardsMapsArray.length; i++) {
		var currentMap = artboardsMapsArray[i]

		var baseLayerPosition = currentMap[[baseLayer name]]
		var currentLayerPosition = currentMap[[currentLayer name]]
		// log(baseLayerPosition + ":" + currentLayerPosition)

		var currentScore = OrderInventory.currentPosition(baseLayerPosition, currentLayerPosition)

		localScore += currentScore
	}
	
	return localScore
}

OrderInventory.addIntoArray = function(item, position, array) {
	var head = NSArray.new()
	if (array == nil) { return head }
	
	for (var i = 0; i < array.count(); i++) {
		var currentItem = [array objectAtIndex:i]
		head = FramerInventory.addItemToArray(currentItem, head)

		if (i == position) { head = FramerInventory.addItemToArray(item, head) }
	}

	return head
}

OrderInventory.analyseOrder = function(unorderedArray) {
	var orderedArray = NSArray.new()
	var prevLayer = nil
	
	if (unorderedArray != nil && unorderedArray.count() > 0) {
		orderedArray = FramerInventory.addItemToArray([unorderedArray firstObject], orderedArray)
	}
	
	for (var i = 1; i < unorderedArray.count(); i++) {
		var currentLayer = [unorderedArray objectAtIndex:i]
		
		if (orderedArray.count() == 0) { break }
		for (var j = orderedArray.count() - 1; j >= 0; j--) {
			var existingLayer = [orderedArray objectAtIndex:j]
			var score = OrderInventory.analyseAveragePosition(existingLayer, currentLayer)

			if (score < 0) {
				orderedArray = OrderInventory.addIntoArray(currentLayer, j, orderedArray)
				break;
			}	
		}
	} 
	
	return orderedArray
}




