@import "Framer-Inventory-for-Sketch/Framer Inventory.sketchplugin/Contents/Sketch/inventory/libs/testing/logger.js"
@import "actions/workers/modals/action-select-opened-project.cocoascript"

function PathInventory () {}


PathInventory.returnProjectNameFromPath = function(projectPath) {
  var currentOpenedProjectCleanPath = [[projectPath componentsSeparatedByString:".framer"] firstObject]
  var currentOpenedProjectName = [[currentOpenedProjectCleanPath componentsSeparatedByString:"/"] lastObject]
  return currentOpenedProjectName
}

PathInventory.returnProjectPathFromURLPath = function(projectPath) {
    var cleanPath = projectPath
    if ([[projectPath componentsSeparatedByString:"file://"] count] > 1) { cleanPath = [[projectPath componentsSeparatedByString:"file://"] lastObject] }
    return [cleanPath stringByRemovingPercentEncoding]
}


PathInventory.returnOpenedFramerProjects = function() {
    var openedFramerProjects = NSMutableDictionary.new()
    var relativePlistPath = NSHomeDirectory() + "/Library/Saved Application State/com.motif.framer.savedState/windows.plist"

    var plistData = [NSData dataWithContentsOfFile:relativePlistPath];
    if (!plistData) { return openedFramerProjects }

    var plistRoot = nil
    var plistSerializationError = nil;

    id plist = [NSPropertyListSerialization propertyListWithData:plistData options:NSPropertyListMutableContainersAndLeaves format:nil error:plistSerializationError];


    if (!plistSerializationError) { plistRoot = plist; }
    else { return openedFramerProjects }

    for (var i = 0; i < plistRoot.count(); i++) {
        var currenPlistBlock = plistRoot[i]

        if ([currenPlistBlock objectForKey:"NSRepresentedURL"]) {
            var currentFramerProjectPath = currenPlistBlock["NSRepresentedURL"]
            var cleanFramerProjectPath = PathInventory.returnProjectPathFromURLPath(currentFramerProjectPath)
            if (cleanFramerProjectPath != "") { openedFramerProjects[currentFramerProjectPath] = cleanFramerProjectPath }
        }
    }

    return openedFramerProjects
}


PathInventory.createPathModal = function() {
  var openedFramerProjects = PathInventory.returnOpenedFramerProjects()

  if (openedFramerProjects.count() == 0) { selectProjectWithNoOpened() }
  else if (openedFramerProjects.count() == 1) {
      userDefaults.exportFramerFolder = [[openedFramerProjects allValues] firstObject]
      saveDefaults(Status.userDomain(), userDefaults)

      [currentDocument showMessage:ViewInventory.smileDone() + "Selected project: " + PathInventory.returnProjectNameFromPath([[openedFramerProjects allValues] firstObject])]
  }
  else { selectOpenedProject(openedFramerProjects) }

  ToolbarInventory.setContentView()
}








PathInventory.readProjectCode = function(prototypePath) {
  if (prototypePath == "") { return [NSString stringWithFormat:"%@", ""]; }
  var codeFilePath = prototypePath + "/app.coffee"

  if ([[NSFileManager defaultManager] fileExistsAtPath:codeFilePath]) {
    return [NSString stringWithContentsOfFile:codeFilePath encoding:NSUTF8StringEncoding error:nil]
  }

  return [NSString stringWithFormat:"%@", ""];
}

PathInventory.replaceProjectCode = function(prototypePath, newCode) {
  if (prototypePath == "") { return }

  var codeFilePath = prototypePath + "/app.coffee"
  writeTextToFile(newCode, codeFilePath)
  return
}



PathInventory.returnNumberArrayFromString = function(taggedPointerString) {
  var pair = NSMutableArray.new()

  var removeSet = [NSMutableCharacterSet characterSetWithCharactersInString:@"{} "];
  var numberFormatter = [[NSNumberFormatter alloc] init];
  numberFormatter.numberStyle = NSNumberFormatterDecimalStyle;

  var removedBracketsString = [[taggedPointerString componentsSeparatedByCharactersInSet:removeSet] componentsJoinedByString:""];
  var stringParts = [removedBracketsString componentsSeparatedByString:","]
  for (var i = 0; i < stringParts.count(); i++) { [pair addObject:[numberFormatter numberFromString:[stringParts objectAtIndex:i]]] }

  return pair
}

PathInventory.readFoldRanges = function(prototypePath) {
    const configFile = prototypePath + '/framer/config.json'
    var data = [NSData dataWithContentsOfFile:configFile];
    var configuration = [NSJSONSerialization JSONObjectWithData:data options:nil error:nil];
    var ranges = [configuration objectForKey:"foldedCodeRanges"]

    return ranges
}

PathInventory.returnFoldRangesArray = function(ranges) {
  var rangesArray = NSMutableArray.new()

  for (var i = 0; i < ranges.count(); i++) {
    var currentRange = [ranges objectAtIndex: i]
    var pair = PathInventory.returnNumberArrayFromString(currentRange)
    [rangesArray addObject:pair]
  }

  return rangesArray
}

PathInventory.updateFoldRanges = function(prototypePath, shiftBy) {
    var ranges = PathInventory.readFoldRanges(prototypePath)
    const newRange = []

    for (var i = 0; i < ranges.count(); i++) {
        var rangeString = [ranges objectAtIndex:i]

        // var firstNumber = parseInt( extractFirstNumber.exec(range)[0] )
        var matches = rangeString.match(/\d+/g)
        var firstNumber = Number(matches[0])
        var firstNumberShift = firstNumber + shiftBy
        newRange.push(rangeString.replace(matches[0], firstNumberShift) )
    }


    /*
    Configuration for code folds is an array of ranges (strings):
    '{ startingCharacterNumber, numberOfCharactersInFold }'
    e.g.:
    "foldedCodeRanges": [
        "{68, 1039}",
        "{1108, 2066}"
    ]
    With every new require() command un/written to app.coffee, we need to shift
    code fold ranges to maintain the folds in Framer Studio.
    e.g. when writing require string that is 68 characters long,
         '{1, 1039}' becomes '{69, 1039}'
    */

    // configuration.foldedCodeRanges.forEach(range => {
       // const firstNumber = parseInt( extractFirstNumber.exec(range)[0] )
       // const firstNumberShift = firstNumber + shiftBy

        // newRange.push( range.replace(extractFirstNumber, firstNumberShift) )
    //})

    //configuration.foldedCodeRanges = newRange

    var newConfiguration = [configuration mutableCopy]
    [newConfiguration setObject:newRange forKey:"foldedCodeRanges"]

    var jsonData = [NSJSONSerialization dataWithJSONObject:newConfiguration options:nil error:nil];
    log(jsonData)
    // log([configuration className])

    [jsonData writeToFile:configFile atomically:true];

    return newRange

}


PathInventory.isFoldRange = function(range, foldRanges) {
    for (var i = 0; i < foldRanges.count(); i++) {
      if ([range isEqualToArray:[foldRanges objectAtIndex:i]]) { return true; }
    }
    return false;
}

PathInventory.createAllFolds = function(readRanges, maxLength) {
    var fileStartIndex = 0
    var zeroLength = 0
    var pairs = NSMutableArray.new()

    var startIndex = 0
    var lengthIndex = 1

    var currentPair = NSMutableArray.new()
    var nextPair = NSMutableArray.new()

    [currentPair addObject:fileStartIndex]
    [currentPair addObject:zeroLength]
    [nextPair addObject:fileStartIndex]
    [nextPair addObject:zeroLength]

    for (var i = 0; i < readRanges.count(); i++) {
        var currentRange = [readRanges objectAtIndex:i]
        // log("----------------#######")
        // log([[currentRange firstObject] intValue])
        // log([[currentPair firstObject] intValue])

        if ([[currentRange firstObject] intValue] == [[currentPair firstObject] intValue]) {
          // log("1:")
          [currentPair replaceObjectAtIndex:lengthIndex withObject:[currentRange lastObject]];
          // log([currentPair firstObject] + [currentPair lastObject])
          [nextPair replaceObjectAtIndex:startIndex withObject:[currentPair firstObject] + [currentPair lastObject]]
          [pairs addObject:[currentPair copy]]
          // log("Added: ")
          // log(currentPair)
        }

        else {
          // log("2:")
          // log(currentPair)

          [currentPair replaceObjectAtIndex:lengthIndex withObject:[currentRange firstObject] - [currentPair firstObject]];
          [pairs addObject:[currentPair copy]]
          // log("Added: ")
          // log(currentPair)

          [currentPair replaceObjectAtIndex:startIndex withObject:[currentRange firstObject]]
          [currentPair replaceObjectAtIndex:lengthIndex withObject:[currentRange lastObject]]
          // log("Next: ")
          [nextPair replaceObjectAtIndex:startIndex withObject:[currentPair firstObject] + [currentPair lastObject]]
          [pairs addObject:[currentPair copy]]
          // log("Added: ")
          // log(currentPair)

        }

        // log("Next Pair to Copy: ")
        // log(nextPair)
        currentPair = [nextPair mutableCopy]
    }

    // log("has some:")
    // log([[currentRange firstObject] intValue] + [[currentRange lastObject] intValue])

    if ([[currentRange firstObject] intValue] + [[currentRange lastObject] intValue] == maxLength) {
      // log("ok")
    }
    else {
      [currentPair replaceObjectAtIndex:lengthIndex withObject:maxLength - [currentPair firstObject]]
      [pairs addObject:[currentPair copy]]
      // log("Added: ")
      // log(currentPair)
    }


    return pairs
}
