@import 'inventory/classes/state.cocoascript'

@import 'inventory/getters/normalize.cocoascript'
@import 'inventory/getters/get-place.cocoascript'
@import 'inventory/strings/generate.cocoascript'


function Layer (layerName, currentPage) {
	// name of layer
	this.layerName = layerName;
	this.states = [];
	
	
	
	// active conditions
	this.areOpacityActive = false
	this.areCornersActive = false
	this.areRotationsActive = false
	
	this.areShadowsActive = false
	this.areInnersActive = false
	this.areBordersActive = false
	this.areBackgroundsActive = true // always export bg
	
	
	// exportable conditions
	this.areShadowsExportable = true
	this.areInnersExportable = true
	this.areBordersExportable = true
	this.areBackgroundsExportable = true
	
	// if equals -> css-filter, else -> images–≥
	this.areAllShadowsEqual = true
	this.areAllBackgroundsExist = true

}



Layer.prototype.getName = function() { return this.layerName }

var ln = function() { return "\n" }
var dln = function() { return ln() + ln() }
var tln = function() { return "\t" }




Layer.prototype.addState = function(layer) {
	var state = new State(layer)
	this.updateConditions(state)
	this.states.push(state)
}

Layer.prototype.addFirstState = function(state) {
	this.updateConditions(state)
	this.states.push(state)
}



Layer.prototype.updateConditions = function(state) {
	// active
	this.areOpacityActive = this.areOpacityActive || state.opacityActive
	this.areCornersActive = this.areCornersActive || state.cornerActive
	this.areRotationsActive = this.areRotationsActive || state.rotationActive
	
	this.areShadowsActive = this.areShadowsActive || state.shadowsActive
	this.areInnersActive = this.areInnersActive || state.innersActive
	this.areBordersActive = this.areBordersActive || state.bordersActive
	this.areBackgroundsActive = this.areBackgroundsActive || state.backgroundsActive
	
	
	
	// exportable
	this.areShadowsExportable = this.areShadowsExportable && state.shadowsExportable
	this.areInnersExportable = this.areInnersExportable && state.innersExportable
	this.areBordersExportable = this.areBordersExportable && state.bordersExportable
	this.areBackgroundsExportable = this.areBackgroundsExportable && state.backgroundsExportable
	
	// exportable for groups and images
	this.areAllShadowsEqual = this.areAllShadowsEqual && this.compareShadows(state)
	this.areAllBackgroundsExist = this.areAllBackgroundsExist && state.backgroundsActive
}



// PRINT

Layer.prototype.printLayer = function() {
	return this.generateFramerStates()
}


Layer.prototype.generateFramerStates = function() {
	if (this.states == nil || this.states.length == 0) {
		if (showLog) { log("Warning: States are empty") }
		return ""
	}
	
	var currentType = this.states[0].type
	var areAllGeneratable = this.areAllGeneratable()
	
	var generatedStates = []
	var statesDescriptions = []
	var statesNames = []
	
	// store values
	var outputNameString = returnLayerName(this.layerName)
	var outputPositionString = ""
	var outputStateString = ""
	var outputImageNameString = ""
	var outputFilterShadowsString = ""
	
	
	var currentState = nil
	var prevState = nil
	var maxSpace = 0
	
	for (var i = 0; i < this.states.length; i++) {
		currentState = this.states[i]
		if (currentState.isEqualToState(prevState)) {
			log("SKIPPED STATE")
			break
		}
		
		outputString = ""
		outputPositionString = ""
		outputOpacityString = ""
		
		if (this.areOpacityActive) {
			if (!currentState.opacityActive) { outputOpacityString = generateAbsoluteOpacity() }
			else { outputOpacityString = generateOpacity(currentState.opacity) }
		}
		
		if (currentType == 2 || currentType == 3) {
			
			// operating with rects and ovals
			if (areAllGeneratable) {
				if (this.areCornersActive) {
					if (!currentState.cornerActive) { outputString += generateAbsoluteCorner() }
					else { outputString += generateCorner(currentState.corner) }
				}
				
				if (this.areRotationsActive) {
					if (!currentState.rotationActive) { outputString += generateAbsoluteRotation() }
					else { outputString += generateRotation(currentState.rotation) }
				}
				
				// always export bg (to override base)
				if (this.areBackgroundsActive) {
					if (this.areAllBackgroundsExist) {
						outputString += generateBackgrounds(currentState.backgrounds)
					}
					else {
						if (!currentState.backgroundsActive) {
							outputString += generatePassiveBackgroundsWithColor(this.getSuggestedBackgroundColor(i))
							outputOpacityString = generateTransparentOpacity()
						}
						else {
							outputString += generateBackgrounds(currentState.backgrounds)
							if (!currentState.opacityActive) { outputOpacityString = generateAbsoluteOpacity() }
							else { outputOpacityString = generateOpacity(currentState.opacity) }
						}
					}
				}
				
				if (this.areShadowsActive) {
					if (!currentState.shadowsActive) { outputString += generatePassiveShadowsWithColor(this.getSuggestedShadowColor(i)) }
					else { outputString += generateShadows(currentState.shadows) }
				}	
				
				if (this.areBordersActive) {
					if (!currentState.bordersActive) { outputString += generatePassiveBordersWithColor(this.getSuggestedBorderColor(i)) }
					else { outputString += generateBorders(currentState.borders) }
				}
		
				outputPositionString += generatePosition(currentState.position)
			}
			else {
				var currentStatePlace = getPlaceImage(currentState.layer)
				var normal = this.normalizeLayer(currentState.layer, false)
				
				var currentSpace = currentStatePlace[0] + currentStatePlace[1]
				if (currentSpace > maxSpace) {
					maxSpace = currentSpace
					this.copyLayerToNormalizedPage(normal)
				}
			
				outputPositionString += generatePosition(currentStatePlace)
				if (outputImageNameString == "") { outputImageNameString = generateImagePath(this.layerName) }
			}
		}
		else if (currentType == 1) {
			
			// operating with groups
			var currentStatePlace = []
			var normal = nil
			
			if (this.areAllShadowsEqual) {

				if (this.areShadowsActive && outputFilterShadowsString == "" && currentState.shadowsActive) {
						outputFilterShadowsString = generateFilterShadows(currentState.shadows)
				}
				
				currentStatePlace = getPlaceImage(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, true)
			}
			else {
				currentStatePlace = getPlaceImage(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, false)
			}
			
			var currentSpace = currentStatePlace[0] + currentStatePlace[1]
			if (currentSpace > maxSpace) {
				maxSpace = currentSpace
				this.copyLayerToNormalizedPage(normal)
			}

			outputPositionString += generatePosition(currentStatePlace)
			if (outputImageNameString == "") { outputImageNameString = generateImagePath(this.layerName) }
			
		}
		else if (currentType == 5) {
			
			// operating with other shapes
			var currentStatePlace = []
			var normal = nil
			
			if (areAllGeneratable && this.areAllShadowsEqual) {

				if (this.areShadowsActive && outputFilterShadowsString == "" && currentState.shadowsActive) {
						outputFilterShadowsString = generateFilterShadows(currentState.shadows)
				}
				
				currentStatePlace = getPlaceRect(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, true)
				
			}
			else {
				currentStatePlace = getPlaceImage(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, false)
			}
			
			var currentSpace = currentStatePlace[0] + currentStatePlace[1]
			if (currentSpace > maxSpace) {
				maxSpace = currentSpace
				this.copyLayerToNormalizedPage(normal)
			}

			outputPositionString += generatePosition(currentStatePlace)
			if (outputImageNameString == "") { outputImageNameString = generateImagePath(this.layerName) }
			
		}
		else {
			log("ERROR. CANT PRINT STATE OF THIS TYPE.")
		}
		
		prevState = currentState
		
		statesDescriptions.push(outputPositionString + outputString + outputOpacityString)
		statesNames.push(currentState.stateName)

	}
	
	for (var i = 0; i < statesDescriptions.length; i++) {
		log(statesNames[i] + " " + statesDescriptions[i])
	}
	
	
	// var googNews = runSimulateKeynoteIdentifier || 0
	// log("TOP: " + goodNews)
	
	if (statesDescriptions.length > 0) {
		outputNameString += statesDescriptions[0] + outputImageNameString + outputFilterShadowsString

		for (var i = 1; i < statesDescriptions.length; i++) {
			generatedStates.push(generateState(statesNames[i], statesDescriptions[i]))
		}
	}

	return outputNameString + dln() + generateStateSection(this.layerName, generatedStates)
	
	
	
	/*
	// for layers and states
	if (currentCommandIdentifier == 0 || currentCommandIdentifier == 1 || currentCommandIdentifier == 3) {
		if (statesDescriptions.length > 0) {
			outputNameString += statesDescriptions[0] + outputImageNameString + outputFilterShadowsString

			for (var i = 1; i < statesDescriptions.length; i++) {
				generatedStates.push(generateState(statesNames[i], statesDescriptions[i]))
			}
		}

		return outputNameString + dln() + generateStateSection(this.layerName, generatedStates)
	}

	// for keynote
	var pageArtboards = FramerInventory.getCurrentPage()
	var artboardsList = [pageArtboards artboards]
	
	var isAlreadyOpacity = true
	
	for (var i = 0, j = 0; i < artboardsList.count(); i++) {
		var artboardName = [[artboardsList objectAtIndex: i] name]
		if (i == 0 && artboardName != statesNames[j]) {
			var line = statesDescriptions[j]
			var fakeDescription = line.substring(0, line.indexOf(', opacity'))
			if (fakeDescription == "") {
				isAlreadyOpacity = false
				fakeDescription = statesDescriptions[j] + ", opacity: 0"
			}
			generatedStates.push(generateState(artboardName, fakeDescription))
			// generatedStates.push(generateState(statesNames[j], statesDescriptions[j]))
		}
		else {
			
		}
		
	}
	
	return generateStateSection(this.layerName, generatedStates)
	*/
	
}


Layer.prototype.returnDifferencedStates = function() {
	var differencedStates = []
	
	if (this.states.length > 0) {
		differencedStates.push(this.states[0])
	}
	
	for (var i = 0; i < this.states.length - 1; i++) {
		var baseState = this.states[i]
		var tempState = baseState.keepDifference(this.states[i + 1])
		
		log("____")
		log("BASE STATE")
		baseState.printState()
		log("____")
		log("TEMP STATE")
		tempState.printState()
		differencedStates.push(tempState)
	}
	
	log("DSL: " + differencedStates.length)
	return differencedStates
}


Layer.prototype.updateStates = function(states) {
	this.states = states
}









Layer.prototype.areAllGeneratable = function(state) {
	return (this.areShadowsExportable && this.areInnersExportable && this.areBordersExportable && this.areBackgroundsExportable) ? true : false
}

Layer.prototype.compareShadows = function(state) {
	if (this.states == nil || state == nil || this.states.length < 1) { return true }
	if (!compareMatrices(this.states[0].shadows, state.shadows)) { return false }
	return true
}











Layer.prototype.getSuggestedShadowColor = function(currentStateNumber) {
	
	for (var i = currentStateNumber; i < this.states.length; i++) {
		if (this.states[i].shadowsActive && (this.states[i].shadow != '' || this.states[i].shadow != nil)) {
			return this.states[i].shadows[0]
		}
	}
	for (var i = currentStateNumber; i >= 0; i--) {
		if (this.states[i].shadowsActive && (this.states[i].shadow != '' || this.states[i].shadow != nil)) {
			return this.states[i].shadows[0]
		}
	}
	return nil
	
}

Layer.prototype.getSuggestedBorderColor = function(currentStateNumber) {
	
	for (var i = currentStateNumber; i < this.states.length; i++) {
		if (this.states[i].bordersActive && (this.states[i].borders != '' || this.states[i].borders != nil)) {
			return this.states[i].borders[0]
		}
	}
	for (var i = currentStateNumber; i >= 0; i--) {
		if (this.states[i].bordersActive && (this.states[i].borders != '' || this.states[i].borders != nil)) {
			return this.states[i].borders[0]
		}
	}
	return nil
	
}

Layer.prototype.getSuggestedBackgroundColor = function(currentStateNumber) {
	
	for (var i = currentStateNumber; i < this.states.length; i++) {
		if (this.states[i].backgroundsActive && (this.states[i].backgrounds != '' || this.states[i].backgrounds != nil)) {
			return this.states[i].backgrounds[0]
		}
	}
	for (var i = currentStateNumber; i >= 0; i--) {
		if (this.states[i].backgroundsActive && (this.states[i].backgrounds != '' || this.states[i].backgrounds != nil)) {
			return this.states[i].backgrounds[0]
		}
	}
	return nil
	
}




// return exportable copy of current layer
Layer.prototype.normalizeCopyForState = function(state) {
	var size_data = {
	    "format": "png",
	    "scale": 2,
	    "suffix": ""
	}
	 
	var baseLayer = state.layer
	var copiedLayer = [baseLayer duplicate]
	[copiedLayer removeFromParent]
	
	var currentPage = FramerInventory.getCurrentPage()
	var framerInventoryPage = FramerInventory.addPage(currentPage)
	FramerInventory.cleanLayer(copiedLayer, framerInventoryPage)
	[framerInventoryPage addLayers: [copiedLayer]]

	
	var size = [[copiedLayer exportOptions] addExportSize]
 	[size setFormat:size_data.format]
    [size setScale:size_data.scale]
    [size setName:size_data.suffix]

	return copiedLayer

}



Layer.prototype.normalizeLayer = function(layer, cleanLayer) {
	if (cleanLayer == nil) { cleanLayer = false }
	
	var layer_copy = [layer duplicate]
	[layer_copy removeFromParent]
	
	if (cleanLayer) { cleanShadows(layer_copy) }
	
	return layer_copy
}


Layer.prototype.copyLayerToNormalizedPage = function(layer) {
	var size_data = {
	    "format": "png",
	    "scale": 2,
	    "suffix": ""
	}
	
	var currentPage = FramerInventory.getCurrentPage()
	var framerInventoryPage = FramerInventory.addPage(currentPage)
	FramerInventory.cleanLayer(layer, framerInventoryPage)
	[framerInventoryPage addLayers: [layer]]
	
	var size = [[layer exportOptions] addExportSize]
 	[size setFormat:size_data.format]
    [size setScale:size_data.scale]
    [size setName:size_data.suffix]
}