@import 'inventory/classes/state.cocoascript'

@import 'inventory/getters/normalize.cocoascript'
@import 'inventory/getters/get-place.cocoascript'
@import 'inventory/strings/generate.cocoascript'


function Layer (layerName, currentPage) {
	// name of layer
	this.layerName = layerName;
	this.states = [];
	
	
	
	// exportable conditions
	this.areAllShadowsExportable = true
	this.areAllInnersExportable = true
	this.areAllBordersExportable = true
	this.areAllBackgroundsExportable = true

}



Layer.prototype.getName = function() { return this.layerName }

var ln = function() { return "\n" }
var dln = function() { return ln() + ln() }
var tln = function() { return "\t" }




Layer.prototype.addState = function(layer) {
	var state = new State(layer)
	this.states.push(state)
	
	this.areAllShadowsExportable = this.areAllShadowsExportable && state.shadowsExportale
	this.areAllInnersExportable = this.areAllInnersExportable && state.innersExportale
	this.areAllBordersExportable = this.areAllBordersExportable && state.bordersExportable
	this.areAllBackgroundsExportable = this.areAllBackgroundsExportable && state.backgroundsExportable
}










// PRINT

Layer.prototype.printLayer = function() {
	if (this.states.length == 1) { return this.generateFramerLayer() }
	return this.generateFramerStates()
}



// print just one layer
Layer.prototype.generateFramerLayer = function() {
	var outputString = ""
	var outputPositionString = returnLayerName(this.layerName)
	
	var currentState = this.states[0]
	var currentType = currentState.type
	
	// useful for both shapes and images
	outputString += generateOpacity(currentState.opacity)
	
	if (currentType == 2 || currentType == 3) {
		if (currentState.generatable) {
			log("SHAPE [EXPORTABLE]")
			outputString += generateCorner(currentState.corner)
			outputString += generateBackgrounds(currentState.backgrounds)
			outputString += generateRotation(currentState.rotation)
			outputString += generateShadows(currentState.shadows)
		
			outputPositionString += generatePosition(currentState.position)
		}
		else {
			log("SHAPE [IMAGE]")

			var normalizedLayer = this.normalizeCopyForState(currentState)
			var temp = getPosition(normalizedLayer)
			
			outputPositionString += generatePosition(temp)
			outputPositionString += generateImagePath(this.layerName)
		}
	}
	else if (currentType == 1) {
		if (currentState.shadowsExportable)) {
			outputString += generateFilterShadows(currentState.shadows)
			
			var normalizedLayer = this.normalizeCopyForState(currentState)
			cleanShadows(normalizedLayer)
			var temp = getPosition(normalizedLayer)
			
			outputPositionString += generatePosition(temp)
			outputPositionString += generateImagePath(this.layerName)
		}
		else {
			var normalizedLayer = this.normalizeCopyForState(currentState)
			var temp = getPosition(normalizedLayer)
			
			outputPositionString += generatePosition(temp)
			outputPositionString += generateImagePath(this.layerName)
		}
	}
	else if (currentType == 5) {
			var normalizedLayer = this.normalizeCopyForState(currentState)
			var temp = getPosition(normalizedLayer)
			
			outputPositionString += generatePosition(temp)
			outputPositionString += generateImagePath(this.layerName)
	}
	else {
		log("ERROR. CANT PRINT LAYER OF THIS TYPE.")
	}
	
	
	
	return "" + outputPositionString + outputString + dln()
}



Layer.prototype.generateFramerStates = function() {
	
	var currentType = this.states[0].type
	var areAllGeneratable = this.areAllGeneratable()
	var generatedStates = []
	
	// store values
	var outputNameString = returnLayerName(this.layerName)
	var outputPositionString = ""
	
	var outputStateString = ""
	
	
	var currentState = nil
	
	for (var i = 0; i < this.states.length; i++) {
		currentState = this.states[i]
		outputString = ""
		outputPositionString = ""

		if (currentType == 2 || currentType == 3) {
			if (areAllGeneratable == 0) {
				outputString += generateCorner(currentState.corner)
				outputString += generateBackgrounds(currentState.backgrounds)
				outputString += generateRotation(currentState.rotation)
				outputString += generateShadows(currentState.shadows)
		
				outputPositionString += generatePosition(currentState.position)
			}
			else {

				var normalizedLayer = this.normalizeCopyForState(currentState)
				var temp = getPosition(normalizedLayer)
			
				outputPositionString += generatePosition(temp)
				outputPositionString += generateImagePath(this.layerName)
			}
		}
		else if (currentType == 1) {
		}
		else if (currentType == 5) {
		}
		else {
			log("ERROR. CANT PRINT STATE OF THIS TYPE.")
		}
		
		var generatedState = generateState(currentState.stateName, outputPositionString + outputString)
		generatedStates.push(generatedState)

	}
	
	return outputNameString + dln() + generateStateSection(this.layerName, generatedStates)

}


















Layer.prototype.areAllGeneratable = function(state) {
	var areAllGeneratable = (this.areAllShadowsExportable || this.areAllInnersExportable || this.areAllBordersExportable || this.areAllBackgroundsExportable) ? 0 : -1
	
	// log("all: " + this.areAllShadowsExportable + " " + this.areAllInnersExportable + " " + this.areAllBordersExportable + " " + this.areAllBackgroundsExportable + " " + this.areAllGeneratable)
	
	return areAllGeneratable
}





// return exportable copy of current layer
Layer.prototype.normalizeCopyForState = function(state) {
	var size_data = {
	    "format": "png",
	    "scale": 2,
	    "suffix": ""
	}
	 
	var baseLayer = state.layer
	var copiedLayer = [baseLayer duplicate]
	[copiedLayer removeFromParent]
	
	
	var newPage = addPage(getCurrentPage())
	deleteLayerOnPage(copiedLayer, newPage)
	[newPage addLayers: [copiedLayer]]

	
	var size = [[copiedLayer exportOptions] addExportSize]
 	[size setFormat:size_data.format]
    [size setScale:size_data.scale]
    [size setName:size_data.suffix]

	return copiedLayer

}