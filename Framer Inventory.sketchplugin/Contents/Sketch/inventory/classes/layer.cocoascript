@import 'inventory/classes/state.cocoascript'

@import 'inventory/getters/normalize.cocoascript'
@import 'inventory/getters/get-place.cocoascript'
@import 'inventory/strings/generate.cocoascript'


function Layer (layerName, currentPage) {
	// name of layer
	this.layerName = layerName;
	this.states = [];
	
	
	
	// active conditions
	this.areOpacityActive = false
	this.areCornersActive = false
	this.areRotationsActive = false
	
	this.areShadowsActive = false
	this.areInnersActive = false
	this.areBordersActive = false
	this.areBackgroundsActive = true // always export bg
	
	
	// exportable conditions
	this.areShadowsExportable = true
	this.areInnersExportable = true
	this.areBordersExportable = true
	this.areBackgroundsExportable = true
	
	// if equals -> css-filter, else -> images–≥
	this.areAllShadowsEqual = true
	this.areAllBackgroundsExist = true

}



Layer.prototype.addState = function(layer) {
	var state = new State(layer)
	this.updateConditions(state)
	this.states.push(state)
}

Layer.prototype.addFirstState = function(state) {
	this.updateConditions(state)
	this.states.push(state)
}



Layer.prototype.updateConditions = function(state) {
	// active
	this.areOpacityActive = this.areOpacityActive || state.opacityActive
	this.areCornersActive = this.areCornersActive || state.cornerActive
	this.areRotationsActive = this.areRotationsActive || state.rotationActive
	
	this.areShadowsActive = this.areShadowsActive || state.shadowsActive
	this.areInnersActive = this.areInnersActive || state.innersActive
	this.areBordersActive = this.areBordersActive || state.bordersActive
	this.areBackgroundsActive = this.areBackgroundsActive || state.backgroundsActive
	
	
	
	// exportable
	this.areShadowsExportable = this.areShadowsExportable && state.shadowsExportable
	this.areInnersExportable = this.areInnersExportable && state.innersExportable
	this.areBordersExportable = this.areBordersExportable && state.bordersExportable
	this.areBackgroundsExportable = this.areBackgroundsExportable && state.backgroundsExportable
	
	// exportable for groups and images
	this.areAllShadowsEqual = this.areAllShadowsEqual && this.compareShadows(state)
	this.areAllBackgroundsExist = this.areAllBackgroundsExist && state.backgroundsActive
}



// PRINT

Layer.prototype.printLayer = function() {
	return this.generateFramerStates()
}


Layer.prototype.generateFramerStates = function() {
	if (this.states == nil || this.states.length == 0) {
		if (showLog) { log("Warning: States are empty") }
		return ""
	}
	
	var currentType = this.states[0].type
	var areAllGeneratable = this.areAllGeneratable()
	
	var generatedStates = []
	var statesDescriptions = []
	var statesNames = []
	
	// store values
	var outputNameString = returnLayerName(this.layerName)
	var outputPositionString = ""
	var outputStateString = ""
	var outputImageNameString = ""
	var outputFilterShadowsString = ""
	
	
	var currentState = nil
	var prevState = nil
	var maxSpace = 0
	
	for (var i = 0; i < this.states.length; i++) {
		currentState = this.states[i]
		if (currentState.isEqualToState(prevState)) {
			log("SKIPPED STATE")
			break
		}
		
		outputString = ""
		outputPositionString = ""
		outputOpacityString = ""
		
		if (this.areOpacityActive) {
			if (!currentState.opacityActive) { outputOpacityString = generateAbsoluteOpacity() }
			else { outputOpacityString = generateOpacity(currentState.opacity) }
		}
		
		if (currentType == 2 || currentType == 3) {
			
			// operating with rects and ovals
			if (areAllGeneratable) {
				if (this.areCornersActive) {
					// ++++++++++++++++++++++++++++
					if (!currentState.cornerActive) { outputString += generateAbsoluteCorner() }
					else { outputString += generateCorner(currentState.corner) }
				}
				
				if (this.areRotationsActive) {
					if (!currentState.rotationActive) { outputString += generateAbsoluteRotation() }
					else { outputString += generateRotation(currentState.rotation) }
				}
				
				// always export bg (to override base)
				if (this.areBackgroundsActive) {
					if (this.areAllBackgroundsExist) {
						outputString += generateBackgrounds(currentState.backgrounds)
					}
					else {
						if (!currentState.backgroundsActive) {
							outputString += generatePassiveBackgroundsWithColor(this.getSuggestedBackgroundColor(i))
							outputOpacityString = generateTransparentOpacity()
						}
						else {
							outputString += generateBackgrounds(currentState.backgrounds)
							if (!currentState.opacityActive) { outputOpacityString = generateAbsoluteOpacity() }
							else { outputOpacityString = generateOpacity(currentState.opacity) }
						}
					}
				}
				
				if (this.areShadowsActive) {
					if (!currentState.shadowsActive) { outputString += generatePassiveShadowsWithColor(this.getSuggestedShadowColor(i)) }
					else { outputString += generateShadows(currentState.shadows) }
				}	
				
				if (this.areBordersActive) {
					if (!currentState.bordersActive) { outputString += generatePassiveBordersWithColor(this.getSuggestedBorderColor(i)) }
					else { outputString += generateBorders(currentState.borders) }
				}
		
				outputPositionString += generatePosition(currentState.position)
			}
			else {
				var currentStatePlace = getPlaceImage(currentState.layer)
				var normal = this.normalizeLayer(currentState.layer, false)
				
				var currentSpace = currentStatePlace[0] + currentStatePlace[1]
				if (currentSpace > maxSpace) {
					maxSpace = currentSpace
					this.copyLayerToNormalizedPage(normal)
				}
			
				outputPositionString += generatePosition(currentStatePlace)
				if (outputImageNameString == "") { outputImageNameString = generateImagePath(this.layerName) }
			}
		}
		else if (currentType == 1) {
			
			// operating with groups
			var currentStatePlace = []
			var normal = nil
			
			if (this.areAllShadowsEqual) {

				if (this.areShadowsActive && outputFilterShadowsString == "" && currentState.shadowsActive) {
						outputFilterShadowsString = generateFilterShadows(currentState.shadows)
				}
				
				currentStatePlace = getPlaceImage(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, true)
			}
			else {
				currentStatePlace = getPlaceImage(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, false)
			}
			
			var currentSpace = currentStatePlace[0] + currentStatePlace[1]
			if (currentSpace > maxSpace) {
				maxSpace = currentSpace
				this.copyLayerToNormalizedPage(normal)
			}

			outputPositionString += generatePosition(currentStatePlace)
			if (outputImageNameString == "") { outputImageNameString = generateImagePath(this.layerName) }
			
		}
		else if (currentType == 5) {
			
			// operating with other shapes
			var currentStatePlace = []
			var normal = nil
			
			if (areAllGeneratable && this.areAllShadowsEqual) {

				if (this.areShadowsActive && outputFilterShadowsString == "" && currentState.shadowsActive) {
						outputFilterShadowsString = generateFilterShadows(currentState.shadows)
				}
				
				currentStatePlace = getPlaceRect(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, true)
				
			}
			else {
				currentStatePlace = getPlaceImage(currentState.layer)
				normal = this.normalizeLayer(currentState.layer, false)
			}
			
			var currentSpace = currentStatePlace[0] + currentStatePlace[1]
			if (currentSpace > maxSpace) {
				maxSpace = currentSpace
				this.copyLayerToNormalizedPage(normal)
			}

			outputPositionString += generatePosition(currentStatePlace)
			if (outputImageNameString == "") { outputImageNameString = generateImagePath(this.layerName) }
			
		}
		else {
			log("ERROR. CANT PRINT STATE OF THIS TYPE.")
		}
		
		prevState = currentState
		
		statesDescriptions.push(outputPositionString + outputString + outputOpacityString)
		statesNames.push(currentState.stateName)

	}
	
	for (var i = 0; i < statesDescriptions.length; i++) {
		log(statesNames[i] + " " + statesDescriptions[i])
	}
	
	if (statesDescriptions.length > 0) {
		outputNameString += statesDescriptions[0] + outputImageNameString + outputFilterShadowsString

		for (var i = 1; i < statesDescriptions.length; i++) {
			generatedStates.push(generateState(statesNames[i], statesDescriptions[i]))
		}
	}

	return outputNameString + dln() + generateStateSection(this.layerName, generatedStates)
	
}


Layer.prototype.returnDifferencedStates = function() {
	if (this.states == nil) { return nil }
	
	var differencedStates = []
	
	var classicalState = this.getClassicalState()
	differencedStates.push(classicalState)
	
	log("--------------------------------------")
	log("CS: " + classicalState.printStateSmall())
	for (var i = 0; i < this.states.length; i++) {
		var state = this.states[i]
		log("BS" + i + ": " + state.printStateSmall())
	}
	
	
	var baseState = classicalState
	for (var i = 0; i < this.states.length; i++) {
		if (i != 0) { baseState = this.states[i - 1] }
		var tempState = baseState.keepDifference(this.states[i])
		
		log("--------------------------------------")
		// log("BS: " + baseState.printStateSmall())
		log("TS: " + tempState.printStateSmall())
		
		differencedStates.push(tempState)
	}
	
	return differencedStates
}


Layer.prototype.updateStates = function(states) {
	this.states = states
	
	// for (var i = 1; i < this.states.length; i++) {
// 		this.updateConditions(this.states[i])
// 	}
}









Layer.prototype.areAllGeneratable = function(state) {
	return (this.areShadowsExportable && this.areInnersExportable && this.areBordersExportable && this.areBackgroundsExportable) ? true : false
}

Layer.prototype.compareShadows = function(state) {
	if (this.states == nil || state == nil || this.states.length < 1) { return true }
	if (!compareMatrices(this.states[0].shadows, state.shadows)) { return false }
	return true
}











Layer.prototype.getSuggestedShadowColor = function(currentStateNumber) {
	
	for (var i = currentStateNumber; i < this.states.length; i++) {
		if (this.states[i].shadowsActive && (this.states[i].shadow != '' || this.states[i].shadow != nil)) {
			return this.states[i].shadows[0]
		}
	}
	for (var i = currentStateNumber; i >= 0; i--) {
		if (this.states[i].shadowsActive && (this.states[i].shadow != '' || this.states[i].shadow != nil)) {
			return this.states[i].shadows[0]
		}
	}
	return nil
	
}

Layer.prototype.getSuggestedBorderColor = function(currentStateNumber) {
	
	for (var i = currentStateNumber; i < this.states.length; i++) {
		if (this.states[i].bordersActive && (this.states[i].borders != '' || this.states[i].borders != nil)) {
			return this.states[i].borders[0]
		}
	}
	for (var i = currentStateNumber; i >= 0; i--) {
		if (this.states[i].bordersActive && (this.states[i].borders != '' || this.states[i].borders != nil)) {
			return this.states[i].borders[0]
		}
	}
	return nil
	
}

Layer.prototype.getSuggestedBackgroundColor = function(currentStateNumber) {
	
	for (var i = currentStateNumber; i < this.states.length; i++) {
		if (this.states[i].backgroundsActive && (this.states[i].backgrounds != '' || this.states[i].backgrounds != nil)) {
			return this.states[i].backgrounds[0]
		}
	}
	for (var i = currentStateNumber; i >= 0; i--) {
		if (this.states[i].backgroundsActive && (this.states[i].backgrounds != '' || this.states[i].backgrounds != nil)) {
			return this.states[i].backgrounds[0]
		}
	}
	return nil
	
}



// find const params for all layers
Layer.prototype.getClassicalState = function() {
	var classicalState = nil
	
	if (this.states != nil && this.states.length > 0) { classicalState = new State(this.states[0].layer) }
	else { return nil }
	
	log("STLENGTH: " + this.states.length)
	
	for (var i = 0; i < this.states.length; i++) {
		
		var state = this.states[i]
		
		if (classicalState.opacity == nil || classicalState.opacity != state.opacity) { classicalState.opacity = nil }
		if (classicalState.corner == nil || classicalState.corner != state.corner) { classicalState.corner = nil }
		if (classicalState.rotation == nil || classicalState.rotation != state.rotation) { classicalState.rotation = nil }
		
		if (classicalState.position != nil && classicalState.position != "" && state.position != nil) {	
			for (var j = 0; j < classicalState.position.length; j++) {
				if (j == 3) {
					log("CP3: " + classicalState.position[j] + " | " + state.position[j])
				}
				if (classicalState.position[j] == nil || classicalState.position[j] != state.position[j]) { classicalState.position[j] = nil }
			}
		}
		
		if (classicalState.shadows == nil || !compareMatrices(classicalState.shadows, state.shadows)) { classicalState.shadows = nil }
		if (classicalState.inners == nil || !compareMatrices(classicalState.inners, state.inners)) { classicalState.inners = nil }
		if (classicalState.borders == nil || !compareMatrices(classicalState.borders, state.borders)) { classicalState.borders = nil }
		if (classicalState.backgrounds == nil || !compareMatrices(classicalState.backgrounds, state.backgrounds)) { classicalState.backgrounds = nil }
	}
	classicalState.stateName = "framer inventory initial"
	
	return classicalState
}







Layer.prototype.normalizeLayer = function(layer, cleanLayer) {
	if (cleanLayer == nil) { cleanLayer = false }
	
	var layer_copy = [layer duplicate]
	[layer_copy removeFromParent]
	
	if (cleanLayer) { cleanShadows(layer_copy) }
	
	return layer_copy
}


Layer.prototype.copyLayerToNormalizedPage = function(layer) {
	var size_data = {
	    "format": "png",
	    "scale": 2,
	    "suffix": ""
	}
	
	var currentPage = FramerInventory.getCurrentPage()
	var framerInventoryPage = FramerInventory.addPage(currentPage)
	FramerInventory.cleanLayer(layer, framerInventoryPage)
	[framerInventoryPage addLayers: [layer]]
	
	var size = [[layer exportOptions] addExportSize]
 	[size setFormat:size_data.format]
    [size setScale:size_data.scale]
    [size setName:size_data.suffix]
}
